任务发布平台:
1 我们直接写一个任务发布程序:
    这个程序可以直接把数据查询出来
2 然后由， 测试/需求经理, 
    把大数据的任务的一个简化版本-任务发布
    做一个简要描述

这要求我们:
简单直接的完成一些任务:
依然是 achileus, 的目标
--------------------------------------------
1 需求直接对接我的小批量代码
    当需求把我的小批量代码验证之后:

产生一个小批量的单元测试:

提交给研发:
填空做大数据函数
------------------------------------------------
这样, 需求经理和研发之间
1 有清晰的交付
2 有单元测试
3 有框架供研发直接填充
-------------------------------------------------
我们简单一点:
先抄一个dbeaver, 

怎样把服务部署到 windows上?
算了, 太不稳定
---------

今天在尝试怎么触发 修改props 的方法
我们觉得应该有一个客户端修改 props, 直接重新显示的方法
现在可以修改， 但是在刷新的时候, 数据没有保存
------------------------------

本来想用一个简单方式实现，
但是现在看来不可能

因此, js 实际上需要分解为几个内容:
1 图像绘制
    需要设计onClick 的传入机制
2 数据收集过程
    多种数据收集方法

1 从服务器端渲染:
    
2 在客户端自己更新数据:

# 数据传输计划:
1 配置类型的

2 批量类型的
json

我们怎么能设计一个机制:
a 先加载一部分组jian, 快速更新
b 缓慢加载批量数据, 流式更新
---------------------------------------------
1 我的poc
2 继续的dataphin
3 逆向数据查询 - 数据血缘
4 系统的适应性
    建议性的而非强制的，这样就可以按照我们的需要， 缓慢替代
--------------------------------------------------
这几天每天都在和next.js战斗, 主要是我尝试在前端储存数据, 这样一部分计算就放在前端
基本失败
周三:
今天构建了一个 flask 小框架
把每个url 变成一个类
----------------------------------------------------------
正在把之前我们写的表展示页面, 简化成一个直接的网页
我们可以使用python 生成.js的页面.按照某个框架
.
----
> 点击按钮，修改无效

前后段数据已经拉通, 就是数据没有刷新！
----------------------------
周五:

最近一个月我主要做了两部分工作:
1 完成一些poc任务(接近3周)
2 low-code项目的前端(熟悉一些概念/技术，以及实现[显示表]) (一周半)

现在我刚刚打通前端的某个技术瓶颈(swr), 进入效率非常高的状态
正在实现如何把一张表显示到前端, 以及使用算子对表进行修改的页面
做完之后计划阶段性收尾

然后我会输出一些相关的文章, 围绕下面几个主题:
1 最近的poc工作对我的启示，包括 与胡琴的合作, 与辛硕的合作, 以及我的方式(low-code)等
2 关于如何实现 low-code 整体工程
    需要的工程能力, 以及我现在的技术储备
3 关于数据处理过程优化方案的设想, 包括: 
    1 不同角色(产品经理/测试/研发)的参与
    2 数据处理任务描述方法
    3 单元测试的可能性
    4 low-code工程 提供的软件支持(需要实现什么样的功能)
----------------------------------------------------------
fetch_table: db152.mysql.sy_cd_comp_new
select_field: f1, f2, f3
cond: f1:xx, f2:xx, f3:xx

收集一下列操作:
所以一张表:
我们要把这个操作, 变成


两个显示条件:
1 select_list 要屏蔽-黑化前面的fields
    这个需要后段给出计算, 前端直接负责显示就行
2 enable_pos 是在算子之间
    <
pos>
    <
    enable_pos 下方的所有算子都失效并黑化

算子的显示和黑化, 由后端直接计算好, 然后传到前端, 前端就不用再
    计算显示-黑化
    重新排序


3 table_page:[
    base_info: fetch_table,
    [select_list, functors],
    functor_enable_pos,
]
    fetch_table: db152.mysql.sy_cd_comp_new
        field_list
        cn_field_list
        type_list
        (select_list 不用显示)
    cond_functor(cond_list, select_list(不用显示))
*   select_functor(select_list, 需要显示)

    record_list(record_list, select_list)
-----------------------------------------------------
我们直接尝试做一个poc


## 2022.3.27
全正向方法:
方法相同, 而非方法不同, 先实现, 在最后应用的时候再彻底检验

1: 造数据
在本地创建mysql-测试库
快速造数据工具, 脚本
>> 实际上是构造测试用例

2: 实现poc
a 生成 pandas代码 > 执行
b 下载 pandas
----------------------------------------
拷贝数据库

前端:
可以增加/修改/查询 db
GEP-
------------------------------------------------------
merge/join 策略
1v1 
    如果 1vn >> 
        a 取第一条+报错
        b 拼接
            b1 如果为空, 怎么办
    如果 nv1 >> 重复复制
    如果 null >> 
        a 报错 + null
.
-------------
自动生成测试用例:
1 对走入不同分支的所有数据, 都保存一条
2 安全执行, 错误退出
--------------------------------------
然后我们把脏数据问题:
探测并按照一个标准格式返回.
上传到任务-
任务反馈刷新---脏数据造成的影响
--------------------------------------------
1 一个条件地图:
    我们能否找到满足一个条件的数据?
        >> 在merge中
        >> 立刻生成一个sql语句
            >> 然后我们放在数据表里面查 >> 没有key >> 不可查询
    失败
    条件地图, 必须跑一次数据才可能明白

1.1 增强条件地图:
    1.1.1
        快速找到一个满足某个条件的数据:
        条件裁减代码-生成:
        提示 在每个key上增加限制条件

    1.1.2 输出数据流
        找到每条数据的流动演变过程
.
--------------------------------------------------------------
> 1 完成简单的 pandas 代码生成
    > 1.0 模型:
        > 构建一个表, 删除一个表 /unit/module/db152.xxx
            > 通过 ddl语句实现
        > 展示一个表:
            >> flask-json  完成.  周一！
            >> 前端表-组件化--> 成功
            >> 表的显示库. debug
    > 1.1 单表:
        手工制作假数据/测试数据
        其实只是把数据库里的特殊数据， 抓出来
    > 1.2 表-函数封装
    

.
javascript:
不仅仅是实现页面
已经可以尝试封装类, 并积累了一些简单易用的工具:
1 显示组件的模块化, 而不是平铺html
2 一些封装好的通信函数/clone函数
3 一些由于 next.js 特殊特性对我们前后端直接造成的曲折实现, 以及demo
-------------------------------------
-------------------------------------
-------------------------

https://zhuanlan.zhihu.com/p/31956362
----------------------------------------------------

# 前端
最近做前端的时候遇到一些障碍, 并构建了一些基本能力:

1 debug能力
debug有点困难，因为javascript-react-next.js
这个技术栈有点长, 所以我在调试的时候，有时候还要区分到底问题在哪一层
所以我用了一些时间熟悉这些调试信息, 积累debug经验

2 swr/ssr 前后端通信
next.js默认使用 ssr, 但是这个模式在我目前这个场景中，有些功能不能实现
所以我用了一些时间，尝试不同的前后端通信方案
目前主要用swr, 做了一些标准化的封装

3 面向对象
由于next.js是在react上面构建的, 以及很多代码是从服务器生成
在某些场景下, 对于面向对象的代码构建不支持
我用了一些时间, 探索绕开这个限制的方法, 得到一些进展

4 函数版本的html组件
一开始写html的时候, 都是零散的手写
现在正在对我需要的一些html内容打包, 复用, 改变成类-函数版本

5 tailwind
初步熟悉一个比较漂亮的css库
用来美化界面风格

6 工具包
我正在积累一些前端开发的lib.

# 后端
用 python-flask做后端
主要因为这个库描述后端比较简洁，会提高开发效率
我基于flask又封装了一层小框架
现在描述一个url的行为更简单

# 数据计算

最近基于pandas做了一些数据计算
弃用之前用python裸写数据处理的方式

主要是为了压缩我需要维护的代码量
也积累了一些工具和库

这部分最后会应用在low-code的计算中
它会起到两个作用:
1 作为一个内置的计算平台
    比如通过[测试数据]验证 [需求定义]的正确性
2 作为第一种自动生成的代码
    后面还可以考虑其他平台/风格:
    1 基于裸python的计算代码
    2 基于pyspark的代码
    3 其他语言版本 - 如java 等
---------------------------------------------

1 我们完成了src + module 的融合

现在需要给 src/module 设计一个新的数据结构
>> 
本周最重要的是:
1 实现具体的任务:
    task-module-src 拉通
    task, 可以分配 src, 进入src修改
    task 的开始条件:
        1 [基础集合]
            [查询表]
        2 [主表]
            [查询表]
    src:
        1 [基础集合] > 手动输入/展示5行/展示全部
        2 [主表] > module + [select,cond]
        3 [查询表] > module + [select,cond] + [key,full_data] + [append_fields]
        >> 我们不考虑手动函数
        >> 无类型, 类型检查以后再做
    >> named_function :函数过程/嵌套调用 不考虑
2 第一版数据描述方案:

2.1 过程 - 抽象描述 - 共相:
    2.1.1 主干+分支
        主干 + 分支
        root/branch/case
        root.db152.xxxxxxx
        branch1.db152.xxxxxxx
        branch2.db152.xxxxxxx
        branch3.db152.xxxxxxx
    2.1.2 输出过程:
        root > out.Excel.xxxxxxx
2.3 原子过程
    2.3.1 输入过程
        2.3.1.1 表查询
        2.3.1.2 名单
    2.3.2 处理过程
        2.3.2.1 列过程
            2.3.2.1 扩展列: 根据名单查询(联表)
            2.3.2.2 删除列: 
            2.3.2.3 重命名列: 
            2.3.2.4 选择列:
            2.3.2.5 手动模式(映射): 手写映射函数改变列， 需要声明列的变化
        2.3.2.2 行过程(过滤)
            pass
        2.3.2.3 分裂:
            条件选择:
                case 1 xxx
                case 2 xxx
        
    2.3.3 输出过程
        2.3.3.1 输出.表(Excel.table)
        2.3.3.2 输出.名单(Excel.list)
        2.3.3.3 数据.数据库(Excel.sheet_dict)

2.4 多分支过程:
    过程基本型:
        root
            branch1
            branch2
            branch3
    引用:
        1 子过程
        2 通用过程
        子过程和通用过程要能够良好转化
2.5 一次性过程:数字过程
2.6 通用过程:工具过程
--------------------------------------------

A 前后端模型 coordinator
我们设计一份模型:
    翻译成两份代码:
        都是纯粹的数据结构/类
    这样我们的数据通信就非常一致
B 后端数据:
    1 模型:
        我们把后端数据, 用web完全展示
    2 业务: 
        我们的业务依赖模型
        原则上业务[不产生]新的数据结构
    3 url之间的资源访问
        我们通过 多线程单例模式+类引用访问实现


下一轮:
1 完成一个同步两个模型的装置
2 
-----------------------------------------------
上周的复杂设计对现在的我的状态来说，不能继续
----
重新回到简洁的设计中:
1 我实现一个最基本的框架:
    1 从多表到单sheet
    2 merge方式是最简单的 11 映射
    3 一共5个算子:
        1 读取表 + select + cond
        2 field_append
        3 row-map
        4 col-filter
        5 write_to_excel_sheet1
    4 固定的函数嵌套
>> 1 python接口实现
1 直接后端json调用
----------------------------------

task:
task.name
functor_list
new_functor_list
task.op

functor_list:
1 读取表 + select + cond
2 field_append
3 row-map
4 col-filter
5 write_to_excel_sheet1
-----------------------------
我们已经建立了一些基本结构
a 可以通过 一些按钮新增算子过程
    ++++
b 我们应该能够删除这些过程
    +++
c 我们尝试修改和显示这些过程
    1 算子的表 ++
        召唤模型
    2 加载表信息 ++
        fields en
        fields cn
        xx fields type
    3 扩展表:
        select 
        cond
    
    >> 0 我们先预留一个收起按钮, 但是无效
        没做， 我们直接默认显示
    >> 我们把后端数据传给了前端
        成功>> 现在需要前端把数据显示

.
-------------------------------------------
-----------------------------------------------------------------

# 基督教保守主义
教育的目的不在于告诉人们，人们获得权力之后必定作恶
统治者接受教育的目的， 是引导自身向善

民主制不是没有专制权力
只是把专制权力分散给多人做统治
但是民主制的教育如果依然预定"人们获得权力则会作恶"
则民主制的统治
不因为是多人的统治而免除恶的统治


西方统治者必须从基督教而来的原因
正是基督教教义对恶的限制
而在西方无神论那里， 作恶不受限制
当西方无神论依靠"文化多元主义"逆转了统治力量
则民主政治的普遍败坏就发生了
@ 
---------------------------------------------------
服务

工具

平台: 给出一些基本工具集
形成一个服务需要使用这些工具集
但也基于自己的创造
平台+社区模式
------------------------------------------------------------------
> 我们已经快要成功了
1  3算子模型
关键是生成代码
提交到git上
xxx
------------------------------------------------------------------
>> 明天:3
1 三算子的一个例子完成
>> 后天:4
2 加载数据模型, db_aliyun + 143
产生代码
>> 周五:5
缓冲日, 写文档

最近我在如何划分前后端的问题上, 不断尝试，积累了一些经验
> 坚持所有逻辑/数据结构 都在后端
> 前端只是使用通用component显示这些数据
------------------------------------------------------------------
显示一行:
我们把风格判断
也放在后端
一行数据:
1 
2 
>> 后端设置一个数据类
>> 前端对应一个compo
# #.
----------------------------------------------------------------
>> 我们今天把代码的结构贯通了
几乎所有逻辑都放在后端
前端只是把我们需要显示的compo显示
前端的数据逻辑被我们清理掉
>> 我们需要把现在的 append
    所有的流程, 都实现:
        >> 增加cond 
        >> 把行变黑, 重排序 功能增加 ++++



