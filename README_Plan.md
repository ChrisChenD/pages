任务发布平台:
1 我们直接写一个任务发布程序:
    这个程序可以直接把数据查询出来
2 然后由， 测试/需求经理, 
    把大数据的任务的一个简化版本-任务发布
    做一个简要描述

这要求我们:
简单直接的完成一些任务:
依然是 achileus, 的目标
--------------------------------------------
1 需求直接对接我的小批量代码
    当需求把我的小批量代码验证之后:

产生一个小批量的单元测试:

提交给研发:
填空做大数据函数
------------------------------------------------
这样, 需求经理和研发之间
1 有清晰的交付
2 有单元测试
3 有框架供研发直接填充
-------------------------------------------------
我们简单一点:
先抄一个dbeaver, 

怎样把服务部署到 windows上?
算了, 太不稳定
---------

今天在尝试怎么触发 修改props 的方法
我们觉得应该有一个客户端修改 props, 直接重新显示的方法
现在可以修改， 但是在刷新的时候, 数据没有保存
------------------------------

本来想用一个简单方式实现，
但是现在看来不可能

因此, js 实际上需要分解为几个内容:
1 图像绘制
    需要设计onClick 的传入机制
2 数据收集过程
    多种数据收集方法

1 从服务器端渲染:
    
2 在客户端自己更新数据:

# 数据传输计划:
1 配置类型的

2 批量类型的
json

我们怎么能设计一个机制:
a 先加载一部分组jian, 快速更新
b 缓慢加载批量数据, 流式更新
---------------------------------------------
1 我的poc
2 继续的dataphin
3 逆向数据查询 - 数据血缘
4 系统的适应性
    建议性的而非强制的，这样就可以按照我们的需要， 缓慢替代
--------------------------------------------------
这几天每天都在和next.js战斗, 主要是我尝试在前端储存数据, 这样一部分计算就放在前端
基本失败
周三:
今天构建了一个 flask 小框架
把每个url 变成一个类
----------------------------------------------------------
正在把之前我们写的表展示页面, 简化成一个直接的网页
我们可以使用python 生成.js的页面.按照某个框架
.
----
> 点击按钮，修改无效

前后段数据已经拉通, 就是数据没有刷新！
----------------------------
周五:

最近一个月我主要做了两部分工作:
1 完成一些poc任务(接近3周)
2 low-code项目的前端(熟悉一些概念/技术，以及实现[显示表]) (一周半)

现在我刚刚打通前端的某个技术瓶颈(swr), 进入效率非常高的状态
正在实现如何把一张表显示到前端, 以及使用算子对表进行修改的页面
做完之后计划阶段性收尾

然后我会输出一些相关的文章, 围绕下面几个主题:
1 最近的poc工作对我的启示，包括 与胡琴的合作, 与辛硕的合作, 以及我的方式(low-code)等
2 关于如何实现 low-code 整体工程
    需要的工程能力, 以及我现在的技术储备
3 关于数据处理过程优化方案的设想, 包括: 
    1 不同角色(产品经理/测试/研发)的参与
    2 数据处理任务描述方法
    3 单元测试的可能性
    4 low-code工程 提供的软件支持(需要实现什么样的功能)
----------------------------------------------------------
fetch_table: db152.mysql.sy_cd_comp_new
select_field: f1, f2, f3
cond: f1:xx, f2:xx, f3:xx

收集一下列操作:
所以一张表:
我们要把这个操作, 变成


两个显示条件:
1 select_list 要屏蔽-黑化前面的fields
    这个需要后段给出计算, 前端直接负责显示就行
2 enable_pos 是在算子之间
    <
pos>
    <
    enable_pos 下方的所有算子都失效并黑化

算子的显示和黑化, 由后端直接计算好, 然后传到前端, 前端就不用再
    计算显示-黑化
    重新排序


3 table_page:[
    base_info: fetch_table,
    [select_list, functors],
    functor_enable_pos,
]
    fetch_table: db152.mysql.sy_cd_comp_new
        field_list
        cn_field_list
        type_list
        (select_list 不用显示)
    cond_functor(cond_list, select_list(不用显示))
*   select_functor(select_list, 需要显示)

    record_list(record_list, select_list)
-----------------------------------------------------
我们直接尝试做一个poc


## 2022.3.27
全正向方法:
方法相同, 而非方法不同, 先实现, 在最后应用的时候再彻底检验

1: 造数据
在本地创建mysql-测试库
快速造数据工具, 脚本
>> 实际上是构造测试用例

2: 实现poc
a 生成 pandas代码 > 执行
b 下载 pandas
----------------------------------------
拷贝数据库

前端:
可以增加/修改/查询 db
GEP-
------------------------------------------------------
merge/join 策略
1v1 
    如果 1vn >> 
        a 取第一条+报错
        b 拼接
            b1 如果为空, 怎么办
    如果 nv1 >> 重复复制
    如果 null >> 
        a 报错 + null
.
-------------
自动生成测试用例:
1 对走入不同分支的所有数据, 都保存一条
2 安全执行, 错误退出
--------------------------------------
然后我们把脏数据问题:
探测并按照一个标准格式返回.
上传到任务-
任务反馈刷新---脏数据造成的影响
--------------------------------------------
1 一个条件地图:
    我们能否找到满足一个条件的数据?
        >> 在merge中
        >> 立刻生成一个sql语句
            >> 然后我们放在数据表里面查 >> 没有key >> 不可查询
    失败
    条件地图, 必须跑一次数据才可能明白

1.1 增强条件地图:
    1.1.1
        快速找到一个满足某个条件的数据:
        条件裁减代码-生成:
        提示 在每个key上增加限制条件

    1.1.2 输出数据流
        找到每条数据的流动演变过程
.
--------------------------------------------------------------
> 1 完成简单的 pandas 代码生成
    > 1.0 模型:
        > 构建一个表, 删除一个表 /unit/module/db152.xxx
            > 通过 ddl语句实现
        > 展示一个表:
            >> flask-json  完成.  周一！
            >> 前端表-组件化--> 成功
            >> 表的显示库. debug
    > 1.1 单表:
        手工制作假数据/测试数据
        其实只是把数据库里的特殊数据， 抓出来
    > 1.2 表-函数封装
    

.
javascript:
不仅仅是实现页面
已经可以尝试封装类, 并积累了一些简单易用的工具:
1 显示组件的模块化, 而不是平铺html
2 一些封装好的通信函数/clone函数
3 一些由于 next.js 特殊特性对我们前后端直接造成的曲折实现, 以及demo
-------------------------------------
-------------------------------------
-------------------------

https://zhuanlan.zhihu.com/p/31956362
----------------------------------------------------

# 前端
最近做前端的时候遇到一些障碍, 并构建了一些基本能力:

1 debug能力
debug有点困难，因为javascript-react-next.js
这个技术栈有点长, 所以我在调试的时候，有时候还要区分到底问题在哪一层
所以我用了一些时间熟悉这些调试信息, 积累debug经验

2 swr/ssr 前后端通信
next.js默认使用 ssr, 但是这个模式在我目前这个场景中，有些功能不能实现
所以我用了一些时间，尝试不同的前后端通信方案
目前主要用swr, 做了一些标准化的封装

3 面向对象
由于next.js是在react上面构建的, 以及很多代码是从服务器生成
在某些场景下, 对于面向对象的代码构建不支持
我用了一些时间, 探索绕开这个限制的方法, 得到一些进展

4 函数版本的html组件
一开始写html的时候, 都是零散的手写
现在正在对我需要的一些html内容打包, 复用, 改变成类-函数版本

5 tailwind
初步熟悉一个比较漂亮的css库
用来美化界面风格

6 工具包
我正在积累一些前端开发的lib.

# 后端
用 python-flask做后端
主要因为这个库描述后端比较简洁，会提高开发效率
我基于flask又封装了一层小框架
现在描述一个url的行为更简单

# 数据计算

最近基于pandas做了一些数据计算
弃用之前用python裸写数据处理的方式

主要是为了压缩我需要维护的代码量
也积累了一些工具和库

这部分最后会应用在low-code的计算中
它会起到两个作用:
1 作为一个内置的计算平台
    比如通过[测试数据]验证 [需求定义]的正确性
2 作为第一种自动生成的代码
    后面还可以考虑其他平台/风格:
    1 基于裸python的计算代码
    2 基于pyspark的代码
    3 其他语言版本 - 如java 等
---------------------------------------------

1 我们完成了src + module 的融合

现在需要给 src/module 设计一个新的数据结构
>> 
本周最重要的是:
1 实现具体的任务:
    task-module-src 拉通
    task, 可以分配 src, 进入src修改
    task 的开始条件:
        1 [基础集合]
            [查询表]
        2 [主表]
            [查询表]
    src:
        1 [基础集合] > 手动输入/展示5行/展示全部
        2 [主表] > module + [select,cond]
        3 [查询表] > module + [select,cond] + [key,full_data] + [append_fields]
        >> 我们不考虑手动函数
        >> 无类型, 类型检查以后再做
    >> named_function :函数过程/嵌套调用 不考虑
2 第一版数据描述方案:

2.1 过程 - 抽象描述 - 共相:
    2.1.1 主干+分支
        主干 + 分支
        root/branch/case
        root.db152.xxxxxxx
        branch1.db152.xxxxxxx
        branch2.db152.xxxxxxx
        branch3.db152.xxxxxxx
    2.1.2 输出过程:
        root > out.Excel.xxxxxxx
2.3 原子过程
    2.3.1 输入过程
        2.3.1.1 表查询
        2.3.1.2 名单
    2.3.2 处理过程
        2.3.2.1 列过程
            2.3.2.1 扩展列: 根据名单查询(联表)
            2.3.2.2 删除列: 
            2.3.2.3 重命名列: 
            2.3.2.4 选择列:
            2.3.2.5 手动模式(映射): 手写映射函数改变列， 需要声明列的变化
        2.3.2.2 行过程(过滤)
            pass
        2.3.2.3 分裂:
            条件选择:
                case 1 xxx
                case 2 xxx
        
    2.3.3 输出过程
        2.3.3.1 输出.表(Excel.table)
        2.3.3.2 输出.名单(Excel.list)
        2.3.3.3 数据.数据库(Excel.sheet_dict)

2.4 多分支过程:
    过程基本型:
        root
            branch1
            branch2
            branch3
    引用:
        1 子过程
        2 通用过程
        子过程和通用过程要能够良好转化
2.5 一次性过程:数字过程
2.6 通用过程:工具过程
--------------------------------------------

A 前后端模型 coordinator
我们设计一份模型:
    翻译成两份代码:
        都是纯粹的数据结构/类
    这样我们的数据通信就非常一致
B 后端数据:
    1 模型:
        我们把后端数据, 用web完全展示
    2 业务: 
        我们的业务依赖模型
        原则上业务[不产生]新的数据结构
    3 url之间的资源访问
        我们通过 多线程单例模式+类引用访问实现


下一轮:
1 完成一个同步两个模型的装置
2 
-----------------------------------------------
上周的复杂设计对现在的我的状态来说，不能继续
----
重新回到简洁的设计中:
1 我实现一个最基本的框架:
    1 从多表到单sheet
    2 merge方式是最简单的 11 映射
    3 一共5个算子:
        1 读取表 + select + cond
        2 field_append
        3 row-map
        4 col-filter
        5 write_to_excel_sheet1
    4 固定的函数嵌套
>> 1 python接口实现
1 直接后端json调用
----------------------------------

task:
task.name
functor_list
new_functor_list
task.op

functor_list:
1 读取表 + select + cond
2 field_append
3 row-map
4 col-filter
5 write_to_excel_sheet1
-----------------------------
我们已经建立了一些基本结构
a 可以通过 一些按钮新增算子过程
    ++++
b 我们应该能够删除这些过程
    +++
c 我们尝试修改和显示这些过程
    1 算子的表 ++
        召唤模型
    2 加载表信息 ++
        fields en
        fields cn
        xx fields type
    3 扩展表:
        select 
        cond
    
    >> 0 我们先预留一个收起按钮, 但是无效
        没做， 我们直接默认显示
    >> 我们把后端数据传给了前端
        成功>> 现在需要前端把数据显示

.
-------------------------------------------
-----------------------------------------------------------------
# 基督教保守主义
教育的目的不在于告诉人们，人们获得权力之后必定作恶
统治者接受教育的目的， 是引导自身向善

民主制不是没有专制权力
只是把专制权力分散给多人做统治
但是民主制的教育如果依然预定"人们获得权力则会作恶"
则民主制的统治
不因为是多人的统治而免除恶的统治


西方统治者必须从基督教而来的原因
正是基督教教义对恶的限制
而在西方无神论那里， 作恶不受限制
当西方无神论依靠"文化多元主义"逆转了统治力量
则民主政治的普遍败坏就发生了
@ 
---------------------------------------------------
服务

工具

平台: 给出一些基本工具集
形成一个服务需要使用这些工具集
但也基于自己的创造
平台+社区模式
------------------------------------------------------------------
> 我们已经快要成功了
1  3算子模型
关键是生成代码
提交到git上
xxx
------------------------------------------------------------------
>> 明天:3
1 三算子的一个例子完成
>> 后天:4
2 加载数据模型, db_aliyun + 143
产生代码
>> 周五:5
缓冲日, 写文档

最近我在如何划分前后端的问题上, 不断尝试，积累了一些经验
> 坚持所有逻辑/数据结构 都在后端
> 前端只是使用通用component显示这些数据
------------------------------------------------------------------
显示一行:
我们把风格判断
也放在后端
一行数据:
1 
2 
>> 后端设置一个数据类
>> 前端对应一个compo
# #.
----------------------------------------------------------------
>> 我们今天把代码的结构贯通了
几乎所有逻辑都放在后端
前端只是把我们需要显示的compo显示
前端的数据逻辑被我们清理掉
>> 我们需要把现在的 append
    所有的流程, 都实现:
        >> 增加cond 
        >> 把行变黑, 重排序 功能增加 ++++
---------------------------------------------------
>> 我们现在正在统一前后端
期望能够实现一个前后端框架， 基于3算子
代码基本格式已经快了
今天尽量搞定！
----------------------------------------------------------
今天工作先暂停，其实已经很好了！

进度:
1 我们增加了 对 plan 进行存取的两个功能
2 我们基本实现了从算子到代码的整个生成过程，并建立了简单的调试环境

>> 我们需要对不同算子生成的具体代码进行实测(现在只是完成了粗糙的参数传递)



## 
.
--------------------------------------------------
# 本轮开发成果
最近一轮开发得到了非常好的进展
我们第一个初级版本的困难部分已经完成
（前后端拉通，前端表示方式的主体设计和部分实现等）
现在工程实现内容主要在后端生成代码
由于框架设计比较合理，这部分工作会比较快收尾
开发时间现在变得可控
可以逐步开始进行确定规划

预计在下一轮开发周期诞生一个初级版本:
1 low-code实现的目标:
    直接让负责需求的同事在低代码平台上
        准确充分的描述任务
    在描述任务完成之后，即产生代码

2 具体将会实现：
    a 用户在前端交互界面制作一个开发计划 [plan]
        用户构建 [主干数据], [扩展数据], [数据输出]
        三项配置
        根据相关提示, 描述需求，填写/选择参数        
    b 用户通过点击代码生成/推送到git 完成代码生产

3 对需求的支持细节：
    a 仅仅以mysql表作为数据源[主干数据]
        支持筛选字段，where过滤条件
    b 在mysql数据库之间, 多表联查(可以跨数据库)[扩展数据]
        支持筛选字段，where过滤条件
    c 把产生的数据结果写入excel[数据输出]


# 我们实现该软件的技术路线
前端：
    最近基本掌握了
    next.js 路由/通信
    javascript语言
    tailwind css
    已经达成了简单可用的整体框架
    
    后面会择机在 
        响应时间
        框架内部封装简洁性(重构)
        用户界面的美化 
    等问题上进行优化
后端:
    对flask进行了良好抽象
    使用非常简洁的描述方式, 构建后端模型

数据处理:
    基于pandas的数据处理以及在之上的简洁封装
    用来对我们产生的代码提供接口支持


# 在低代码平台的研发过程的开发阶段
第一阶段:研究构思和技术积累
到今天基本完成
(在和辛硕合作poc的时候，
我把很多需要开发的基于pandas的数据处理过程嵌入到我平时的开发过程中
这导致我在当时开发效率比较慢，现在回想起来还是有点不好意思
)

第二阶段：低代码平台的阿尔法版本

这个阶段我自己先使用它，完成poc
我期望得到的支持是:
1 每周接受两个poc任务, 从简单到困难, poc任务数量逐渐增加
    最好是我在周一拿到需求， 在周四/周五交付
    让我有充足的时间，在没有太大交付压力的情况下
    使用低代码平台完成任务，解决遇到的bug，以及扩展它的功能

2 在我每周能够完成poc任务数量大幅增长之后(比如说每周完成10-20个)
    我最好能够把这个平台向负责需求的同事推广
    我们讨论该平台的使用体验，以及一些优化建议

    最终期望达到的效果是代码由负责需求的同事直接产生
    不必经过开发人员的干预(出现问题, 把出现的bug提给我)
    但是有些复杂情况下，可能需要嵌入一些简单函数，所以后面还需要有相关的设计

第三阶段：
也许可以考虑跨语言，跨平台的功能
以及实现其他自动化需求



后续将陆续增加的更多的功能:
数据来源:
    -手动录入
列:
    -列映射
行:
    -行过滤(在查询mysql之后的某环节)
    -行-合并统计（多行变一行）
    -行-展开（一行变多行）

数据集:
    -并联
输出:
    其他输出方式

    a 数据来源:
        -手动录入
        -非mysql源
    b 列:
        -列映射
    c 行:
        -行过滤(在查询mysql之后的某环节)
        -行-合并统计（多行变一行）
        -行-展开（一行变多行）
    d 数据集:
        -并联
    e 输出:
        其他输出方式, 如输出到mysql
# 
.
---------------------------------------------
> 先增加我们构建一个任务的便利操作
> 然后再考虑生成代码？
.
--------------------------------------
不, 我们这次为了能够在两周之内实现
还是先完成直接的任务
-----------------------------------------------
1 从谱系 [xxx] 里面查询所有公司
2 查询该公司控股的所有公司
3 所有公司增加工商4码
.
-----
这两天:
1 完成代码生成任务
2 我们直接在现有compo上进行轻微修改，将就用一下
-----------------------------
今天:
1 下周要做视频
这一节研究一下怎么做视频
-------------------------------------------



----------------------------------------------
读书作为一个休息流程:
1 每30-80分钟, 就要中断一次去读书
2 读书之后, 收拾屋子(优先保证读书的环境是良好的)

游戏:
我们依然保留游戏:
我们设定一个懒散的游戏目标, 然后不期待执行

视频:
我们把游戏和视频, 都当作一个小型目标.
每天控制在1小时左右
-------------------------------------------
文艺问题:
1 每天看一节小视频:
    20分钟
完成
----------------------



每日任务:
1 完成3-6个代码任务
    1 现在我不知道怎么把canvas 写游戏的代码整合到
        >> 我们绕过这个问题
    2 直接写canvas小游戏
        初始化用 一个init button决定
    

2 视频20分钟
    +++
    刷1个人的社交媒体1-3天
    


3 看书3段-9段精读(+复习)
    ++++
4 游戏一节
    ++++
5 保证中午睡眠
    没有
6 keep 20分钟
    打架1小时
7 下楼静坐20分钟*2




法学大佬
https://www.zhihu.com/question/68717310



